import requests,base64,yaml,sys,os,math,copy
sys.path.append(os.path.abspath( os.path.join( os.path.dirname(__file__),".."))) #ÂºïÂÖ•logÊâÄÂú®ÁªùÂØπÁõÆÂΩï
import log
import secure
import tcp
import webutility
from convert2clash import *
from parserNode import *
import geoip2.database
import socket,  concurrent.futures




class clash:
    proxy_list = {
        'proxy_list': [],
        'proxy_names': []
    } 

    #ÂëΩÂêçÊï∞Â≠ó
    vmess = [] 
  
    def __init__(self,clashOption) -> None:
        self.opt=clashOption
        pass
    
    def parseYamlNode(nodes:list):
        '''
        Ëß£ÊûêYamlÊñá‰ª∂‰∏≠ÁöÑnode ËäÇÁÇπ
        nodes: yaml.get('proxies') ÊàñËÄÖ yaml.get('Proxy')
        return :nodes Âü∫Êú¨‰∏ä‰πüÊòØËøîÂõû ÂèÇÊï∞Ôºå‰ªÖ‰ΩúÊï¥ÁêÜËøáÊª§
        '''
        nodes_list = []
        for node in nodes:
            node['name'] = node['name'].strip() if node.get('name') else None
            node['server']=node['server'].strip()
            # ÂØπclashRÁöÑÊîØÊåÅ
            if node.get('protocolparam'):
                node['protocol-param'] = node['protocolparam']
                del node['protocolparam']
            if node.get('obfsparam'):
                node['obfs-param'] = node['obfsparam']
                del node['obfsparam']
            node['udp'] = True
            node['port'] = int(node['port']) 
                
            if node.get('name')==None: continue
            nodes_list.append(node)
        return nodes_list
    def parseYaml(yamlContent): # Ëß£ÊûêyamlÊñáÊú¨
        try:
            yml = yaml.load(yamlContent, Loader=yaml.FullLoader) 
            tmp_list = []
            # clashÊñ∞Â≠óÊÆµ
            if yml.get('proxies'):tmp_list = yml.get('proxies')
            # clashÊóßÂ≠óÊÆµ
            elif yml.get('Proxy'):tmp_list = yml.get('Proxy')
            else:log.warn('clashËäÇÁÇπÊèêÂèñÂ§±Ë¥•,clashËäÇÁÇπ‰∏∫Á©∫') 
            return clash.parseYamlNode(tmp_list) 
        except:
            raise

    def parseNodeText(text:str| bytes): # Ëß£Êûê ‰ªé base64 Ëß£ÊûêÂá∫Êù•ÁöÑÊñáÊú¨ 
        '''
        Ëß£ÊûêËäÇÁÇπ
        '''
        nodes_list = text.splitlines() 
        if type(text) == str:
            nodes_list=[itm.encode("utf-8") for itm  in nodes_list]
        clash_node= []
        for node in nodes_list: 
            try:
                if node.startswith(b'vmess://'):
                    decode_proxy = decode_v2ray_node([node]) 
                    clash_node.extend(v2ray_to_clash(decode_proxy))
 
                elif node.startswith(b'ss://'):
                    decode_proxy = decode_ss_node([node])
                    clash_node.extend( ss_to_clash(decode_proxy))
                    
                elif node.startswith(b'ssr://'):
                    decode_proxy = decode_ssr_node([node])
                    clash_node.extend(ssr_to_clash(decode_proxy))

                elif node.startswith(b'trojan://'):
                    decode_proxy = decode_trojan_node([node])
                    clash_node.extend(trojan_to_clash(decode_proxy))
                else:
                    pass 
            except Exception as e:
                log.err(e)
                raise 
        if len(clash_node)>0:return clash_node


    def __getHttpContent(url,proxy:str=None):
        try:
            response = webutility.get(url,proxy=proxy)  
            #print("Encoding:"+response.apparent_encoding,response.encoding)
            response.encoding="utf-8"
            return response.text 
        except Exception as e:
            log.err(f"[-]httpËØ∑Ê±Ç'{url}'Âá∫Áé∞ÂºÇÂ∏∏Ôºö{e}")
            pass
    def _genNode(self,nodeContent,nodeContentAddress:str|None): 
        try:
            nodes_list=[]
            yamlData=yaml.full_load(nodeContent) 
            if type (yamlData) == dict: #yaml Ê†ºÂºè
                log.succ(f"{type(yamlData)}‚Äôyaml dict‚Äò<--{nodeContentAddress}")
                nodes_list=clash.parseYaml(nodeContent)
            elif type (yamlData) == list and type(yamlData[0]) == dict: #yaml Ê†ºÂºè‰∏≠ÁöÑËäÇÁÇπ
                log.succ(f"{type(yamlData)} ‚Äôyaml list dict‚Äò<--{nodeContentAddress}")
                nodes_list=clash.parseYamlNode(yamlData)
            else: # base64Âä†ÂØÜ or node list
                log.succ(f"{type(yamlData)} ‚ÄôTEXT‚Äò<--{nodeContentAddress}")
                rawTxt = base64.b64decode(nodeContent) if secure.base64.isBase64(nodeContent) else nodeContent 
                #log.err(f"{type(rawTxt)},\n{rawTxt}")
               
                nodes_list=clash.parseNodeText(rawTxt)
        except Exception as e:
            log.err('[-]Ëß£ÊûêËäÇÁÇπÂ§±Ë¥•:"{}",{}'.format(e,nodeContentAddress))
            pass
        num=0
        if nodes_list!=None:
            node_names = [node.get('name') for node in nodes_list] 
            num=len(node_names)
            self.proxy_list['proxy_list'].extend(nodes_list)
            self.proxy_list['proxy_names'].extend(node_names)
            log.succ(f'[+]ËÆ¢ÈòÖ{nodeContentAddress} clashËäÇÁÇπÊï∞:{num}‰∏™')  
            

    def genNodeByUrl(self,subUrl:str):
        '''
        ‰ªéurl‰∏≠ÁîüÊàêËäÇÁÇπ 
        subUrl      urlÂú∞ÂùÄ
        '''
    
        log.info(f"ËÆ¢ÈòÖÔºö'{subUrl}'...") 
        response=clash.__getHttpContent(subUrl,self.opt.proxy)
        if response==None and opt.proxy!=None:response=clash.__getHttpContent(subUrl)
        if response==None :return 
        self._genNode(response,subUrl)
    
    def genNodeByFile(self,filePath:str):
        '''
        ‰ªéurl‰∏≠ÁîüÊàêËäÇÁÇπ 
        subUrl      urlÂú∞ÂùÄ
        ''' 
        log.info(f"ËÆ¢ÈòÖÔºö'{filePath}'...") 
        if not os.path.exists(filePath) or not os.path.isfile(filePath):log.warn(f"ËæìÂÖ•ÁöÑÊñá‰ª∂Ë∑ØÂæÑ'{filePath}'‰∏çÂ≠òÂú®ÔºÅ")
        file=open(filePath,"r",encoding="utf-8") 
        content=file.read()
        file.close()
        self._genNode(content,filePath)

    def genNodeList(self,urlList): #ÁîüÊàê proxy_list 
        '''
        ‰ªéURLÂàóË°®‰∏≠ÁîüÊàêËäÇÁÇπ
        arg: urlList        base64 url|yaml url node list url
        '''
        # ËØ∑Ê±ÇËÆ¢ÈòÖÂú∞ÂùÄ
        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
            futures={executor.submit(self.genNodeByUrl,(url)) for url in urlList}
        concurrent.futures.wait(futures,return_when=concurrent.futures.FIRST_COMPLETED)
        #for future in concurrent.futures.as_completed(futures):
        #    future.done()

    # Ëé∑ÂèñÊú¨Âú∞ËßÑÂàôÁ≠ñÁï•ÁöÑÈÖçÁΩÆÊñá‰ª∂
    def load_local_config(path):
        try:
            f = open(path, 'r', encoding="utf-8")
            local_config = yaml.load(f.read(), Loader=yaml.FullLoader)
            f.close()
            return local_config
        except FileNotFoundError:
            log.err(f'ÈÖçÁΩÆÊñá‰ª∂{path}Âä†ËΩΩÂ§±Ë¥•')
            sys.exit(0)

    def getTemplateConfig(url, path,proxy:str=None):
        try:
            raw =   webutility.get(url, timeout=5,proxy=proxy).content.decode('utf-8')
            template_config = yaml.load(raw, Loader=yaml.FullLoader)
        except requests.exceptions.RequestException as e:
            log.warn(f'ÁΩëÁªúËé∑ÂèñËßÑÂàô{url}ÈÖçÁΩÆÊ®°ÊùøÂ§±Ë¥•,Âä†ËΩΩÊú¨Âú∞ÈÖçÁΩÆÊñá‰ª∂:\n{e}')
            template_config =clash.load_local_config(path)
        except Exception as e: 
            log.warn(f'ÁΩëÁªúËé∑ÂèñËßÑÂàô{url}ÈÖçÁΩÆÊ®°ÊùøÂ§±Ë¥•,Âä†ËΩΩÊú¨Âú∞ÈÖçÁΩÆÊñá‰ª∂,ÂºÇÂ∏∏‰ø°ÊÅØÔºö\n\t{e}')
            template_config =clash.load_local_config(path)
        log.info('[+]Â∑≤Ëé∑ÂèñËßÑÂàôÈÖçÁΩÆÊñá‰ª∂')
        return template_config
    
    def find_country(server):
        emoji = {
            'AD': 'üá¶üá©', 'AE': 'üá¶üá™', 'AF': 'üá¶üá´', 'AG': 'üá¶üá¨',
            'AI': 'üá¶üáÆ', 'AL': 'üá¶üá±', 'AM': 'üá¶üá≤', 'AO': 'üá¶üá¥',
            'AQ': 'üá¶üá∂', 'AR': 'üá¶üá∑', 'AS': 'üá¶üá∏', 'AT': 'üá¶üáπ',
            'AU': 'üá¶üá∫', 'AW': 'üá¶üáº', 'AX': 'üá¶üáΩ', 'AZ': 'üá¶üáø',
            'BA': 'üáßüá¶', 'BB': 'üáßüáß', 'BD': 'üáßüá©', 'BE': 'üáßüá™',
            'BF': 'üáßüá´', 'BG': 'üáßüá¨', 'BH': 'üáßüá≠', 'BI': 'üáßüáÆ',
            'BJ': 'üáßüáØ', 'BL': 'üáßüá±', 'BM': 'üáßüá≤', 'BN': 'üáßüá≥',
            'BO': 'üáßüá¥', 'BQ': 'üáßüá∂', 'BR': 'üáßüá∑', 'BS': 'üáßüá∏',
            'BT': 'üáßüáπ', 'BV': 'üáßüáª', 'BW': 'üáßüáº', 'BY': 'üáßüáæ',
            'BZ': 'üáßüáø', 'CA': 'üá®üá¶', 'CC': 'üá®üá®', 'CD': 'üá®üá©',
            'CF': 'üá®üá´', 'CG': 'üá®üá¨', 'CH': 'üá®üá≠', 'CI': 'üá®üáÆ',
            'CK': 'üá®üá∞', 'CL': 'üá®üá±', 'CM': 'üá®üá≤', 'CN': 'üá®üá≥',
            'CO': 'üá®üá¥', 'CR': 'üá®üá∑', 'CU': 'üá®üá∫', 'CV': 'üá®üáª',
            'CW': 'üá®üáº', 'CX': 'üá®üáΩ', 'CY': 'üá®üáæ', 'CZ': 'üá®üáø',
            'DE': 'üá©üá™', 'DJ': 'üá©üáØ', 'DK': 'üá©üá∞', 'DM': 'üá©üá≤',
            'DO': 'üá©üá¥', 'DZ': 'üá©üáø', 'EC': 'üá™üá®', 'EE': 'üá™üá™',
            'EG': 'üá™üá¨', 'EH': 'üá™üá≠', 'ER': 'üá™üá∑', 'ES': 'üá™üá∏',
            'ET': 'üá™üáπ', 'EU': 'üá™üá∫', 'FI': 'üá´üáÆ', 'FJ': 'üá´üáØ',
            'FK': 'üá´üá∞', 'FM': 'üá´üá≤', 'FO': 'üá´üá¥', 'FR': 'üá´üá∑',
            'GA': 'üá¨üá¶', 'GB': 'üá¨üáß', 'GD': 'üá¨üá©', 'GE': 'üá¨üá™',
            'GF': 'üá¨üá´', 'GG': 'üá¨üá¨', 'GH': 'üá¨üá≠', 'GI': 'üá¨üáÆ',
            'GL': 'üá¨üá±', 'GM': 'üá¨üá≤', 'GN': 'üá¨üá≥', 'GP': 'üá¨üáµ',
            'GQ': 'üá¨üá∂', 'GR': 'üá¨üá∑', 'GS': 'üá¨üá∏', 'GT': 'üá¨üáπ',
            'GU': 'üá¨üá∫', 'GW': 'üá¨üáº', 'GY': 'üá¨üáæ', 'HK': 'üá≠üá∞',
            'HM': 'üá≠üá≤', 'HN': 'üá≠üá≥', 'HR': 'üá≠üá∑', 'HT': 'üá≠üáπ',
            'HU': 'üá≠üá∫', 'ID': 'üáÆüá©', 'IE': 'üáÆüá™', 'IL': 'üáÆüá±',
            'IM': 'üáÆüá≤', 'IN': 'üáÆüá≥', 'IO': 'üáÆüá¥', 'IQ': 'üáÆüá∂',
            'IR': 'üáÆüá∑', 'IS': 'üáÆüá∏', 'IT': 'üáÆüáπ', 'JE': 'üáØüá™',
            'JM': 'üáØüá≤', 'JO': 'üáØüá¥', 'JP': 'üáØüáµ', 'KE': 'üá∞üá™',
            'KG': 'üá∞üá¨', 'KH': 'üá∞üá≠', 'KI': 'üá∞üáÆ', 'KM': 'üá∞üá≤',
            'KN': 'üá∞üá≥', 'KP': 'üá∞üáµ', 'KR': 'üá∞üá∑', 'KW': 'üá∞üáº',
            'KY': 'üá∞üáæ', 'KZ': 'üá∞üáø', 'LA': 'üá±üá¶', 'LB': 'üá±üáß',
            'LC': 'üá±üá®', 'LI': 'üá±üáÆ', 'LK': 'üá±üá∞', 'LR': 'üá±üá∑',
            'LS': 'üá±üá∏', 'LT': 'üá±üáπ', 'LU': 'üá±üá∫', 'LV': 'üá±üáª',
            'LY': 'üá±üáæ', 'MA': 'üá≤üá¶', 'MC': 'üá≤üá®', 'MD': 'üá≤üá©',
            'ME': 'üá≤üá™', 'MF': 'üá≤üá´', 'MG': 'üá≤üá¨', 'MH': 'üá≤üá≠',
            'MK': 'üá≤üá∞', 'ML': 'üá≤üá±', 'MM': 'üá≤üá≤', 'MN': 'üá≤üá≥',
            'MO': 'üá≤üá¥', 'MP': 'üá≤üáµ', 'MQ': 'üá≤üá∂', 'MR': 'üá≤üá∑',
            'MS': 'üá≤üá∏', 'MT': 'üá≤üáπ', 'MU': 'üá≤üá∫', 'MV': 'üá≤üáª',
            'MW': 'üá≤üáº', 'MX': 'üá≤üáΩ', 'MY': 'üá≤üáæ', 'MZ': 'üá≤üáø',
            'NA': 'üá≥üá¶', 'NC': 'üá≥üá®', 'NE': 'üá≥üá™', 'NF': 'üá≥üá´',
            'NG': 'üá≥üá¨', 'NI': 'üá≥üáÆ', 'NL': 'üá≥üá±', 'NO': 'üá≥üá¥',
            'NP': 'üá≥üáµ', 'NR': 'üá≥üá∑', 'NU': 'üá≥üá∫', 'NZ': 'üá≥üáø',
            'OM': 'üá¥üá≤', 'PA': 'üáµüá¶', 'PE': 'üáµüá™', 'PF': 'üáµüá´',
            'PG': 'üáµüá¨', 'PH': 'üáµüá≠', 'PK': 'üáµüá∞', 'PL': 'üáµüá±',
            'PM': 'üáµüá≤', 'PN': 'üáµüá≥', 'PR': 'üáµüá∑', 'PS': 'üáµüá∏',
            'PT': 'üáµüáπ', 'PW': 'üáµüáº', 'PY': 'üáµüáæ', 'QA': 'üá∂üá¶',
            'RE': 'üá∑üá™', 'RO': 'üá∑üá¥', 'RS': 'üá∑üá∏', 'RU': 'üá∑üá∫',
            'RW': 'üá∑üáº', 'SA': 'üá∏üá¶', 'SB': 'üá∏üáß', 'SC': 'üá∏üá®',
            'SD': 'üá∏üá©', 'SE': 'üá∏üá™', 'SG': 'üá∏üá¨', 'SH': 'üá∏üá≠',
            'SI': 'üá∏üáÆ', 'SJ': 'üá∏üáØ', 'SK': 'üá∏üá∞', 'SL': 'üá∏üá±',
            'SM': 'üá∏üá≤', 'SN': 'üá∏üá≥', 'SO': 'üá∏üá¥', 'SR': 'üá∏üá∑',
            'SS': 'üá∏üá∏', 'ST': 'üá∏üáπ', 'SV': 'üá∏üáª', 'SX': 'üá∏üáΩ',
            'SY': 'üá∏üáæ', 'SZ': 'üá∏üáø', 'TC': 'üáπüá®', 'TD': 'üáπüá©',
            'TF': 'üáπüá´', 'TG': 'üáπüá¨', 'TH': 'üáπüá≠', 'TJ': 'üáπüáØ',
            'TK': 'üáπüá∞', 'TL': 'üáπüá±', 'TM': 'üáπüá≤', 'TN': 'üáπüá≥',
            'TO': 'üáπüá¥', 'TR': 'üáπüá∑', 'TT': 'üáπüáπ', 'TV': 'üáπüáª',
            'TW': 'üáπüáº', 'TZ': 'üáπüáø', 'UA': 'üá∫üá¶', 'UG': 'üá∫üá¨',
            'UM': 'üá∫üá≤', 'US': 'üá∫üá∏', 'UY': 'üá∫üáæ', 'UZ': 'üá∫üáø',
            'VA': 'üáªüá¶', 'VC': 'üáªüá®', 'VE': 'üáªüá™', 'VG': 'üáªüá¨',
            'VI': 'üáªüáÆ', 'VN': 'üáªüá≥', 'VU': 'üáªüá∫', 'WF': 'üáºüá´',
            'WS': 'üáºüá∏', 'XK': 'üáΩüá∞', 'YE': 'üáæüá™', 'YT': 'üáæüáπ',
            'ZA': 'üáøüá¶', 'ZM': 'üáøüá≤', 'ZW': 'üáøüáº',
            'RELAY': 'üèÅ',
            'NOWHERE': 'üá¶üá∂',
        }
        if server.replace('.', '').isdigit():ip = server
        else:
            try:
                # https://cloud.tencent.com/developer/article/1569841
                ip = socket.gethostbyname(server)
            except Exception:
                ip = server
        with geoip2.database.Reader('./file/ip/Country.mmdb') as ip_reader:
            try:
                response = ip_reader.country(ip)
                country_code = response.country.iso_code
            except Exception:
                ip = '0.0.0.0'
                country_code = 'NOWHERE'

        if country_code == 'CLOUDFLARE':
            country_code = 'RELAY'
        elif country_code == 'PRIVATE':
            country_code = 'RELAY'
        if country_code in emoji:
            name_emoji = emoji[country_code]
        else:
            name_emoji = emoji['NOWHERE']
        return '[' + name_emoji + ']'
    
 
    def remove_duplicates(nodeList): # ÂéªÈáç
        result = []
        servers = []
        i = 1
        for item in nodeList:
            if 'name' in item:
                if 'server' not in item or 'port' not in item: continue
                domain = item['server']
                port = item['port']
                server=f"{domain}:{port}" 
                if server in servers:
                    log.warn(f"ÈáçÂ§çËäÇÁÇπÔºö{server}")
                    continue  
                servers.append(server)
                #re.match ‰ªéÂ≠óÁ¨¶‰∏≤ÂºÄÂßãÁöÑÂú∞ÊñπÂåπÈÖçÔºå
                #re.search ‰ªéÁªôÂÆöÂ≠óÁ¨¶‰∏≤‰∏≠ÂØªÊâæÁ¨¨‰∏Ä‰∏™ÂåπÈÖçÁöÑÂ≠êÂ≠óÁ¨¶‰∏≤
                #ÈÉΩÂè™ËÉΩÂåπÈÖç‰∏Ä‰∏™
                name=""
                match=re.search('[\u4e00-\u9fa5]+',item['name'])
                if match !=None: name=match.group() 
                '''
                ÂêçÁß∞ËΩ¨Êç¢‰∏∫ÊåáÂÆöÊ†ºÂºè
                ''' 
                '''
                pattern = '[^\u4e00-\u9fa5\d]+'
                item['name'] = re.sub(pattern, '', item['name'] ) 
                item['name'] = re.sub(r'\d', '', item['name'])
                location = item['name'][:3] 
                # Check for duplicate names and append an index if needed
                original_name = location
                index = 1
                while item['name'] in namesl:
                    item['name'] = original_name + '_' + str(index)
                    index += 1

                namesl.append(item['name'])
                item['name'] = location + '_' + str(i)
                '''

                item['name']=clash.find_country(domain)+ name+'_' + str(i)
                result.append(item)
                i += 1
        return result
    # Â∞Ü‰ª£ÁêÜÊ∑ªÂä†Âà∞ÈÖçÁΩÆÊñá‰ª∂
    def add_proxies_to_model(data, model): 
        if data is None or model is None:
            raise ValueError('Invalid input: data and model cannot be None')
        if 'proxy_list' not in data or 'proxy_names' not in data:
            raise ValueError('Invalid input: data should contain "proxy_list" and "proxy_names" keys')
        
        try: 
            if model.get('proxies') is None:
                model['proxies'] = data.get('proxy_list')
            else:
                model['proxies'].extend(data.get('proxy_list'))
        except Exception as e:
            log.err(f'Error adding proxies to model: {e}')

        try:
            data['proxy_list'] = [d for d in data['proxy_list'] if 'name' in d]
            names = []
            for item in data['proxy_list']:
                if item['name'] not in names:names.append(item['name'])

            for group in model.get('proxy-groups'):
                if group.get('proxies') is None:
                    #group['proxies'] = data.get('proxy_names')
                    group['proxies'] = names
                else:
                    #group['proxies'].extend(data.get('proxy_names'))
                    group['proxies'].extend(names)
        except Exception as e:
            log.err(f'Error adding proxy names to groups: {e}')
        return model

    # ‰øùÂ≠òÂà∞Êñá‰ª∂
    def save_to_file(file_name, content):
        with open(file_name, 'wb') as f:
            f.write(content)

    # ‰øùÂ≠òÈÖçÁΩÆÊñá‰ª∂
    def save_config(path, data): 
        config = yaml.dump(data, sort_keys=False, default_flow_style=False, encoding='utf-8', allow_unicode=True)
        clash.save_to_file(path, config)
        log.info('[+]ÊàêÂäüÊõ¥Êñ∞{}‰∏™ËäÇÁÇπ'.format(len(data['proxies'])))
    
    def checkNode(node,delay=2000):
        '''
        Ê£ÄÊµãËäÇÁÇπ
        node : ËäÇÁÇπ
        delay: Ë∂ÖÊó∂ ÊØ´ÁßíÔºàË∂ÖËøáËØ•Êó∂Èó¥‰∏∫Â§±Ë¥•Ôºâ
        '''
        if 'server' not in node or 'port' not in node or 'password' in node:
            return False 
        domain = node['server']
        domain=domain .strip()
        node['server']=domain
        port = node['port']
        result=tcp.check_tcp_port({"host":domain,"port":port})
        #log(f"Ê£ÄÊµãËäÇÁÇπÁªìÊûú:{result}")
        status=result["status"]
        if status:
            delay=tcp.ping(domain) 
            #log(f"Ê£ÄÊµãÁΩëÁªúÂª∂ËøüÔºö{domain}: {delay} ms")
            if delay== None or delay >delay: status= False
        return status
    
    def checkNodes(nodeList,delay:int=1000):
        '''
        Ê£ÄÊµãËäÇÁÇπ
        '''
        # ÂéªÈáç 
        _nodeList=[]
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures={executor.submit(clash.checkNode,item,delay):item for item in nodeList}
            for future in concurrent.futures.as_completed(futures): 
                item=futures[future] 
                if(future.result()):
                    _nodeList.append(item)
                    log.info(f"[+]'{item['server']}:{item['port']}'.")
                else: log.info(f"[-]'{item['server']}:{item['port']}'.")

        #nameList=[node.get("name") for node in nodeList]     
        return _nodeList
    
    def outputToFile(yamlConfig,nodeList:list,yamlNodeNum:int,outputPath:str): 
        log.info(f'[+]ËäÇÁÇπÊï∞...{len(nodeList)}')
        index=math.floor(len(nodeList) / yamlNodeNum)  
        index+=1 if len(nodeList) % yamlNodeNum > 0 else 0
        i=0
       
        while i<index:
            ii=i*yamlNodeNum
            jj=(i+1)*yamlNodeNum
            data={"proxy_list":[],"proxy_names":[]}
            data["proxy_list"]=nodeList[ii:jj]
            data["proxy_names"]=[item["name"] for item in data["proxy_list"]] 
          
            #ËæìÂá∫Êñá‰ª∂Â§π
            if i>0: outputPath=os.path.splitext(outputPath)[0]+str(i)+os.path.splitext(outputPath)[1]
            _yamlConfig=copy.deepcopy( yamlConfig )
            final_config =clash.add_proxies_to_model(data, _yamlConfig) 
            clash.save_config(outputPath, final_config)
            i+=1
            
    def genYamlForClash(self,yamlNodeNum:int):
        '''
        desc: ÁîüÊàêyaml Êñá‰ª∂
        yamlNodeNum: yaml ËäÇÁÇπÊï∞
        '''
        self.genNodeList(self.opt.subUrlArray) 
        nodelist=clash.remove_duplicates(self.proxy_list['proxy_list'])
        print("*"*8,self.opt.checkNode)
        if self.opt.checkNode: nodelist=clash.checkNodes(nodelist) 
        log.info("Ëé∑ÂèñÂØºÂá∫ÈÖçÁΩÆÊ®°Êùø...")
        yamlConfig=clash.getTemplateConfig(self.opt.templateUrl,self.opt.backLocalTemplate,self.opt.proxy)
        clash.outputToFile(yamlConfig,nodelist,yamlNodeNum,  self.opt.outputPath)
        
            
class clashOption():
    def __init__(self,subArray=list):
        #Ê®°Êùø __xxxx ÁßÅÊúâÂ±ûÊÄß‰∏çËÉΩË¢´ÁªßÊâø
        self.__templateUrl="https://raw.githubusercontent.com/w1770946466/Auto_proxy/main/config.yaml" 
        self.__templateUrl="https://raw.githubusercontent.com/co6co/pytonDemo/master/file/clashConfigTemplate.yaml"
        # Â§áÁî®Êú¨Âú∞Ê®°Êùø
        self.__backLocalTemplate="./default_config.yaml"
        self.subUrlArray=subArray
        #ËæìÂá∫
        self.__outputPath='./file/output.yaml'
        self.__delay=1000
        self.__proxy=None
        self.__checkNode=False
    
    @property  #ÂÉèËÆøÈóÆÂ±ûÊÄß‰∏ÄÊ†∑ËÆøÈóÆÊñπÊ≥ï
    def templateUrl(self): 
        return self.__templateUrl
    @templateUrl.setter
    def templateUrl(self,value:str):
        self.__templateUrl=value

    @property  #Â§áÁî®Êú¨Âú∞Ê®°Êùø
    def backLocalTemplate(self): 
        return self.__backLocalTemplate
    @backLocalTemplate.setter
    def backLocalTemplate(self,value:str):
        self.__backLocalTemplate=value
    
    @property
    def outputPath(self):
        return self.__outputPath
    @outputPath.setter
    def outputPath(self,value:str):
        self.__outputPath=value

    @property
    def delay(self):
        return self.__delay
    @delay.setter
    def delay(self,value:int):
        self.__delay=value
    
    @property
    def proxy(self):
        return self.__proxy
    @proxy.setter
    def proxy(self,value:str):
        self.__proxy=value

    @property
    def checkNode(self):
        return self.__checkNode
    @checkNode.setter
    def checkNode(self,value:bool):
        self.__checkNode=value

    



if __name__ == '__main__': 
    opt=clashOption(subArray=["https://tt.vg/evIzX"])
    cl =clash (opt)
    cl.genYamlForClash()



